<!--

  This file was generated by https://github.com/dsb-infra/.github-private/blob/main/github-copilot-files/auto-generate/update-files.sh

  To update/re-generate this file, run the following command in bash:
    echo 'auto' | bash <(gh api -H "Accept: application/vnd.github.v3.raw" /repos/dsb-infra/.github-private/contents/github-copilot-files/auto-generate/update-files.sh);

-->
# GitHub Copilot Instructions for Terraform Module Projects

This document provides guidance for GitHub Copilot when working with Terraform modules that follow the company's standard structure.

The structure documented here is based on HashiCorp's recommended practices for modules that will be published to the Terraform Registry.

## File Contents and naming conventions

- **main.tf**: Contains the primary resources created by the module, local variables, and data sources
- **variables.tf**: Defines all input variables with descriptions, types, defaults, and validations
- **outputs.tf**: Defines all outputs with descriptions
- **versions.tf**: Specifies required Terraform version and provider versions

## Code Tests

The module should include both unit tests and integration tests:

1. Unit tests (`unit-tests.tftest.hcl`):
   - Test variable validations
   - Test resource attributes
   - Test naming conventions
   - Should use mock providers to avoid real resource creation
   - Should cover all possible input variable values, both negative and positive tests.
   - Should cover all available outputs, both positive and negative tests.

2. Integration tests:
   - Should use real resources but can be run in a separate environment
   - Usually, examples are used for integration tests, e.g.:
     - Basic example tests (`integration-test-basic.tftest.hcl`)
     - Full example tests (`integration-test-full.tftest.hcl`)
   - Additional integration tests can are added as needed.

## Code Linting

TFLint is used for linting. The configuration file is in `.tflint.hcl` and includes:

- Terraform language rules
- Provider-specific rules
- Formatting rules

## Example Usage Pattern

The following usage examples should always be included. More examples should be added for modules supporting more complex usage patterns. The examples should be self-contained and demonstrate different use cases of the module.

1. Basic example:
   - Uses minimal required variables
   - Uses default values for most parameters

2. Full example:
   - Demonstrates all features
   - Overrides default values
   - Shows complex configurations
<!-- markdownlint-disable MD041 first-line-heading/first-line-h1 -->
## Project Directory Structure

A compliant Terraform module should adhere to this directory structure.

The goal is to maintain consistency across all modules within the organization.

### Root Directory

- `main.tf` - Main module resources and implementation
- `variables.tf` - Input variable declarations
- `outputs.tf` - Output value declarations
- `versions.tf` - Terraform and provider version constraints
- `README.md` - Module documentation, partially generated by terraform-docs
- `CHANGELOG.md` - Version history using conventional commits
- `LICENSE.md` - License information
- `renovate.json` - Configuration for Renovate bot dependency updates

### Examples

Note: the number of examples may vary based on the complexity of the module. Each example should be self-contained and demonstrate different use cases.

- `examples/` - Example implementations of the module
  - `01-basic/` - Minimal example with default values
    - `main.tf` - Basic implementation
    - `variables.tf` - Example-specific variables
    - `outputs.tf` - Example outputs
    - `README.md` - Example documentation, fully generated by terraform-docs
  - `02-full/` - More complex example with all features
    - `main.tf` - Advanced implementation
    - `variables.tf` - Example-specific variables
    - `outputs.tf` - Example outputs
    - `README.md` - Example documentation, fully generated by terraform-docs

### Tests

Terraform test files are those named `*.tftest.hcl` and are used for both unit and integration tests.

- `tests/` - Test configurations
  - `common-test.auto.tfvars` - Common test variables
  - `unit-tests.tftest.hcl` - Unit tests for module validation
  - `integration-test-basic.tftest.hcl` - Tests for basic example
  - `integration-test-full.tftest.hcl` - Tests for full example

### Configuration

- `.terraform-docs.yml` - Configuration for terraform-docs
- `.tflint.hcl` - Configuration for TFLint
- `.github/workflows/` - CI/CD workflows
  - `test.yaml` - Testing workflow
  - `tag-and-release.yaml` - Release process workflow
- `.github/copilot/` - GitHub Copilot configuration
  - `instructions.md` - Instructions for GitHub Copilot (this file)

### Documentation

The directory for additional documentation is:

- `docs/`

#### Automatically generated

- `examples/*/README.md` - README for example directories. See "Command invocations for working with the project" for details on how to generate.

#### Partially generated

- `README.md` - Root README for the module. See "Command invocations for working with the project" for details on how to generate.

#### Manually maintained

- `docs/Development.md` - Help for developers of the module.
<!-- markdownlint-disable MD041 first-line-heading/first-line-h1 -->
## Command invocations for working with the project

### Code Validation

These are the commands to validate the code in the project. The commands should be executed from bash in the root directory of the project.

```shell
  # Init project, run fmt and validate
  terraform init -reconfigure
  terraform fmt -recursive
  terraform validate

  # Lint with TFLint, calling script from https://github.com/dsb-norge/terraform-tflint-wrappers
  alias lint='curl -s https://raw.githubusercontent.com/dsb-norge/terraform-tflint-wrappers/main/tflint_linux.sh | bash -s --'
  lint

  # Validate all example directories
  for example_dir in examples/*/; do
    dir_name=${example_dir%*/}
    if ! terraform -chdir=${dir_name} init; then echo "terraform init failed in ${dir_name}"; break; fi
    if ! terraform -chdir=${dir_name} validate; then echo "terraform validate failed in ${dir_name}"; break; fi
    if ! terraform -chdir=${dir_name} fmt -check; then echo "terraform fmt check failed in ${dir_name}"; break; fi
    if ! .tflint/tflint -chdir=${dir_name} --config .tflint.hcl; then echo "tflint failed in ${dir_name}"; break; fi
  done
```

### Code Testing

These are the commands to test the code in the project. The commands should be executed from bash in the root directory of the project.

#### Run all tests

This is to run all tests in the project. The user must supply:

- the subscription GUID for the Azure account to use for running tests

```shell
  # Run tests using built-in terraform testing framework
  az account set --subscription '[GUID GOES HERE]'
  ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv) terraform test
```

#### Apply an example

This is to apply one of the example directories. The user must supply:

- the subscription GUID for the Azure account to use for running tests
- the example directory to apply

```shell
  sub_guid='[GUID GOES HERE]'
  dir_name='[NAME OF EXAMPLE DIR GOES HERE]'

  az account set --subscription "${sub_guid}"
  example_dir="examples/${dir_name}"
  if ! terraform -chdir=${dir_name} init; then
    echo "terraform init failed in ${dir_name}"
    if ! ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv) terraform -chdir=${dir_name} apply; then
      echo "terraform apply failed in ${dir_name}"
    fi
  fi
```

### Update automatically generated documentation

```shell
# go1.17+
go install github.com/terraform-docs/terraform-docs@latest
export PATH=$PATH:$(go env GOPATH)/bin

# root
terraform-docs .

# docs for examples
for ex_dir in $(find "./examples" -maxdepth 1 -mindepth 1 -type d | sort); do
  terraform-docs "${ex_dir}" --config ./examples/.terraform-docs.yml
done
```
<!-- markdownlint-disable MD041 first-line-heading/first-line-h1 -->
## Coding guidelines for Terraform

These are the coding guidelines for Terraform. The goal is to maintain consistency for all usage of Terraform throughout the organization.

### Naming Conventions

1. Use only lowercase letters and underscores for resource names, variable names and outputs.
2. Use underscores to separate multiple words in names.
3. Resource names should have descriptive names and not be pluralized.
4. Use nouns for resource names and do not include the resource type in the name.
5. Wrap the resource type and name in double quotes in your resource definition.

### Resource Management

1. Prefer using `for_each` over `count` for resource creation. Except for single conditional resources, these should use `count`, and either be set to 0 or 1.
2. Group related resources together in the same file or module.
3. Use the `depends_on` attribute explicitly only when Terraform cannot automatically determine dependencies.
4. Implement proper deletion protection for critical resources.

### Code Documentation

1. Use # for single and multi-line comments.
2. README.md file in the root directory should provide an overview.
3. More detailed documentation can be added in the `docs/` directory.
4. Documentation in `*.md` files between the tags `<!-- BEGIN_TF_DOCS -->` and `<!-- END_TF_DOCS -->` are auto-generated by terraform-docs, do not edit them manually.
5. Document all non-obvious design decisions in code comments.
6. Add inline comments for complex expressions or workarounds.
7. Document any assumptions made in your Terraform code.

### Variables & Outputs

1. Include a type and description for every variable.
2. Always include detailed descriptions for variables and outputs.
3. Outputs should represent the key information needed by consumers.
4. Output primitive data types when possible (e.g., string, number, bool), not entire resource objects.
5. Use variable validation blocks to enforce constraints on input values.
6. Mark sensitive outputs appropriately with the `sensitive = true` attribute.
7. For complex variable types, include examples in the description.

### Code Organization & Formatting

1. Indent two spaces for each nesting level.
2. Use multiline heredoc syntax for long descriptions. These should follow this syntax:

    ```hcl
    variable "a_variable_name" {
      description = <<-DESCRIPTION
        Heredoc style should always start with '<<-DESCRIPTION'

        Over multiple lines if needed.

        Can contain code blocks, follow markdown syntax but do not add language specification.

        For example, this is a code block:

        ```
        #!/usr/env/bin bash

        # code block
        gh auth login
        ```

        Heredoc style should always end with 'DESCRIPTION' indented 2 spaces more than where the description declaration starts.
        DESCRIPTION
      type        = string
      nullable    = false
    }
    ```

3. When multiple arguments with single-line values appear on consecutive lines at the same nesting level, align their equals signs.
4. Use empty lines to separate logical groups of arguments within a block.
5. Avoid cluttering resource declarations with logic. Prefer to use locals or variables to simplify the resource declaration.
6. Prefer to order resources in the order they are created. With the goal that each `*.tf` file can be read by a human as a recipe/script from top to bottom. Data resources should be declared just before the resources that use them.
7. Avoid making `*.tf` files too large to be comprehensible by humans. Break it into smaller files if necessary grouped logically by functionality. Use a consistent naming convention like `main.nsgs.tf`, `main.vnet.tf`, etc. Applies to `main.tf`, `variables.tf` and `outputs.tf`.
8. Use format on save in your editor. This ensures `terraform fmt` is run on every save.
